#rm(list=ls())
source('./dmc/models/RW/dists.R')
source('./parameterRecoveries/utils.R')  # simulation function here

# Can we recover? ---------------------------------------------------------
source ("dmc/dmc.R")
source('utils.R')
load_model ("RW", "arw-RL-mag.R")

# some names for saving
modelName = 'arw-RL-mag'
samplesDir <- 'parameterRecoveries/samples'

dataName <- 'parameterRecovery-exp-n9000'
fn = paste0('model-', modelName, '_data-', dataName)

#### Model set-up ----
model <- model.dmc(p.map=list(A="1",t0="1",st0="1",s="1",
                              B0="1", wS='1',
                              SR="1", aV="1",
                              V0="1", wV="1"),
                   match.map=list(M=list(s1=1, s1=2)),
                   constants=c(st0=0, s=1,
                               SR=-10, A=0),
                   factors=list(S=c("s1")), 
                   responses=c("r1","r2"),
                   type="norm")

p.vector  <- c(t0=.2, aV=-1.6, wS=1,
               wV=1, B0=1, V0=1.5)

#samples <- loadSamples(fn='model-arw-RL-mag_data-exp1', samplesDir='samples')
#samplesSummary <- summary.dmc(samples)
#medianPars <- data.frame(do.call(rbind, lapply(samplesSummary, function(x) x$quantiles[,3])))

#### Data ----
# Simulate data with the median estimated parameters and the exact same design
nSubs <- 250
# Let's simulate a design with in total 9 stimuli sets (this would typically be three experimental blocks) with varying difficulty (reward contingencies)
setProbability <- list(c(0.2, 0.8), c(0.2, 0.8), c(0.2, 0.8),
                       c(0.3, 0.7), c(0.3, 0.7), c(0.3, 0.7),
                       c(0.4, 0.6), c(0.4, 0.6), c(0.4, 0.6))
setProbability <- rep(setProbability, 10) # 90 stimulus sets
nTrialsPerSet <- 100  # each stimulus set is shown 100 times, so we have 90*100 = 9000 trials per participant

allData <- NULL
trueParameters <- list()
for(s in 1:nSubs) {
  while(TRUE) {  # this is generally bad coding practice
    B0 <- rnorm(1, mean=2, sd=1)
    V0 <- rnorm(1, mean=2, sd=1)
    wV <- rnorm(1, mean=3, sd=1)
    wS <- rnorm(1, mean=0.5, sd=1)
    aV <- pnorm(rnorm(n=1, mean=-2.3, sd=1))  # learning rate, sampled on a logit scale and then transformed to normal scale
    t0 <- max(rnorm(1, .3, .1), 0.025)
    if(any(c(B0, V0, wV)<0)) next  # these parameters cant be lower than 0, generate again
    
    data <- simulate.full(nTrialsPerSet = nTrialsPerSet, nSets=length(setProbability),   # function defined in parameterRecoveryUtils.R
                          B=B0, v0=V0, wV=wV, wS=wS, t0=t0, alpha=aV,
                          setProbability = setProbability)
    
    if(mean(data$RT) > 1) next  # too slow
    if(mean(data$RT) < 0.3) next  # too fast
    if(mean(data$R==2) < 0.6) next  # no learning / accuracy not high enough
    if(mean(data$R==2) > 0.9) next  # accuracy too high, too few observations of 'error' distribution
    
    ## in real data, error RTs are slower (in one of my RL datasets, ~1.081 (SD 0.098) times slower) than correct RTs 
    ## The asymmetry between error and correct RTs is important for recovery parameters when using lower trial numbers
    ## For datasets with (overall) slow RTs and symmetric RT distributions for correct and incorrect answers,
    ## B0 and t0 start to trade off strongly (I believe this is also the issue that Dora has with using a racing Wald as a stop-signal
    ## accumulator?
    ## Luckily, the error RTs are in real data typically slower than correct RTs. This asymmetry provides an additional constraint
    ## to disentangle B0 from t0 effects.
    ## anyway, maybe try to first generate and recover *without* this asymmetry constraint?
    # if(mean(data$RT[data$R==1])  <= 1.1*mean(data$RT[data$R==2])) next
    break
  }
  trueParameters[[s]] <- c(B0=B0, V0=V0, wV=wV, wS=wS, aV=aV, t0=t0)
  data$s = s
  print(s)  # progress
  allData <- rbind(allData, data)
}
allData$s <- factor(allData$s)
save(allData, trueParameters, file = './parameterRecoveries/data/parameterRecovery-exp-sim-n9000.RData')

load('./parameterRecoveries/data/parameterRecovery-exp-sim-n9000.RData')
### ugly work-around, sorry about this
allData$rt <- allData$RT
allData$choiceIsHighP <- ifelse(allData$R==2, 1, 0)

cvs <- list()
choiceIdx <- list()
for(sub in unique(allData$s)) {
  d <- prepareForFitting(allData[allData$s==sub,])
  cvs[[sub]] <- d$outcomes
  choiceIdx[[sub]] <- d$VVchoiceIdx
}
data <- allData  # convert to DMC style data frame
data$S <- factor('s1')
data$R <- factor(data$R, levels=c(1,2), labels=c('r1', 'r2'))
data <- data.model.dmc(data[,c('s', 'S', 'R', 'RT', 'stimulus_set')], model)

# append cvs by sub as well
for(sub in unique(allData$s)) {
  d <- prepareForFitting(allData[allData$s==sub,])
  attr(data[[sub]], 'cvs') <- d$outcomes
  attr(data[[sub]], 'VVchoiceIdx') <- d$VVchoiceIdx
  attr(data[[sub]], 'startingValues') <- d$values
  attr(data[[sub]], 'trialsToIgnore') <- d$trialsToIgnore
}

# Check model, only need this when you are developing
# likelihood.dmc(p.vector, data[[1]])
# simulate.dmc(p.vector, model=model, n=nrow(data[[1]]), adapt=TRUE, cvs=attr(data[[1]], 'cvs'))

#### Priors ----
pp.prior <- getPriors(p.vector)

#### Sample  -----------------------------------------------------------------
doSample(data, pp.prior[[1]], pp.prior, nmcBurn=250, nmc=1000, nCores=30, restart=FALSE, fileName=file.path(samplesDir, fn))


# 
# # # ## check fit
# load('./parameterRecoveries/samples/model-arw-RL-mag_data-parameterRecovery-exp1.RData')
# load('./parameterRecoveries/data/parameterRecovery-exp1.RData')
# samples <- hsamples; rm(hsamples)
# #plot.dmc(samples)
# 
# posteriorSummary <- summary.dmc(samples)
# 
# trueParams <- data.frame(do.call(rbind, trueParameters))
# posteriorMedian <- data.frame(do.call(rbind, lapply(posteriorSummary, function(x) x$quantiles[,3])))
# posteriorMinCI <- data.frame(do.call(rbind, lapply(posteriorSummary, function(x) x$quantiles[,1])))
# posteriorMaxCI <- data.frame(do.call(rbind, lapply(posteriorSummary, function(x) x$quantiles[,5])))
# 
# posteriorMinCI$B <- posteriorMinCI$B0
# posteriorMinCI$alpha <- pnorm(posteriorMinCI$aV)
# posteriorMinCI$v0 <- posteriorMinCI$V0
# posteriorMinCI <- posteriorMinCI[,colnames(trueParams)]
# 
# posteriorMaxCI$B <- posteriorMaxCI$B0
# posteriorMaxCI$alpha <- pnorm(posteriorMaxCI$aV)
# posteriorMaxCI$v0 <- posteriorMaxCI$V0
# posteriorMaxCI <- posteriorMaxCI[,colnames(trueParams)]
# 
# posteriorMedian$B <- posteriorMedian$B0
# posteriorMedian$alpha <- pnorm(posteriorMedian$aV)
# posteriorMedian$v0 <- posteriorMedian$V0
# posteriorMedian <- posteriorMedian[,colnames(trueParams)]
# 
# rmse <- function(x, y) {
#   sqrt(mean((x-y)^2))
# }
# 
# pdf(file='figures/exp1-parrec.pdf', width=6, height=4)
# par(oma=c(0,0,0,0), mar=c(3, 4, 2, 0.75) + 0.1, mfrow=c(2,3), mgp=c(2.75,.75,0), las=1)
# plot.arrows=FALSE
# for(parName in colnames(posteriorMedian)) {
#   x <- trueParams[,parName]
#   y <- posteriorMedian[,parName]
#   cimin <- posteriorMinCI[,parName]
#   cimax <- posteriorMaxCI[,parName]
#   col=1
#   
#   # Rename parameters for plot. Note that a = threshold
#   if(parName == 'B') { main <- expression(italic('a')); legend.pos='bottomright'}
#   if(parName == 'v0') { main <- expression(italic('V'[0])); legend.pos='bottomright'}
#   if(parName == 'wV') { main <- expression(italic('w'['D'])); legend.pos='bottomright'}
#   if(parName == 'wS') { main <- expression(italic('w'['S'])); legend.pos='bottomright'}
#   if(parName == 't0') { main <- expression(italic('t'[0])); legend.pos='bottomright'}
#   if(parName == 'alpha') { main <- expression(italic(alpha)); legend.pos='bottomright'}
# 
#   if(plot.arrows) {
#     ylim <- c(min(cimin), max(cimax))
#   } else {
#     ylim <- c(min(y), max(y))+c(-.1, .1)
#   }
#   plot(x, y, xlab='', ylab='Median posterior', main=main, type='n', ylim=ylim)
#   mtext('Data-generating value', side=1, line=2, cex=0.66)
#   abline(a=0, b=1)
#   points(x, y, col=col)
#   if(plot.arrows) arrows(x, cimin, x, cimax, length=0.05, angle=90, code=3, col=col)
#   tmp <- legend(legend.pos, c(" ", " "), bty='n', xjust=1, 
#                 text.width = strwidth("RMSE = 0.03"))
#   text(tmp$rect$left + tmp$rect$w, tmp$text$y,
#        c(paste0('r = ', round(cor(x, y), 2)), 
#          paste0('RMSE = ', round(rmse(x,y), 2))), pos = 2)
# }
# dev.off()
# 
# apply((trueParams < posteriorMaxCI) & (trueParams > posteriorMinCI), 2, mean)
